---
id: language-grammar
slug: /language-beginning/language-grammar
title: Грамматика языка спецификации
description: Что такое грамматика языка спецификации? Как она реализована?
sidebar_position: 0
sidebar_label: 3.1. Грамматика языка спецификации
---

import ChapterInfo from '@site/src/components/ChapterInfo/ChapterInfo'
import BlockQuote from '@site/src/components/BlockQuote/BlockQuote'
import FigureImage from '@site/src/components/FigureImage/FigureImage'

<ChapterInfo type='formal' complexity='normal' time='17' />
<BlockQuote id={3}>[^1]</BlockQuote>

# Глава 3.1: Грамматика языка спецификации

В этой главе хотелось бы поговорить о принципах грамматики языка спецификации ECMAScript. Впервые мы
прикоснёмся к спецификации с точки зрения её исследователей, чтобы понять, как она устроена; увидим
разницу между языком спецификации и самим языком ECMAScript и сделаем соответствующие выводы. Сможем
потренироваться на картинках и научимся различать термины языка спецификации.

## Личная рекомендация

Спецификация [ECMAScript Language Specification](https://github.com/tc39/ecma262) написана на
английском языке. В ней присутствуют различные термины, без которых не получится понять базовые
принципы её устройства. В целях соблюдения семантического смысла и сохранения предельной точности
выражений **_перевод этих терминов не рекомендуется_**. В данном случае потребуется запомнить слова
такими, какими они представлены в спецификации. Например, если где-то указано слово "_production_",
рекомендуется запомнить его таким, какое оно есть - без перевода. Это касается всех терминов
спецификации. Так мы не только избежим путаниц, но и образуем свой "_словарик_" терминов, который
успешно сможем использовать в любой подходящей ситуации, например, международная конференция.

:::warning

Разбираемые далее термины никак не относятся к языку ECMAScript! Как было описано в предыдущей
главе, мы дифференциировали 2 противоположных направления спецификации ECMAScript, и сейчас
рассматриваем _язык спецификации_.

:::

## Теория языка

Как вообще можно создать язык под свои нужны? Можно придумать свой алфавит, но это будет слишком
долго, сложно и нерационально, потому что всем придётся учить ваш язык перед прочтением
составленного на нём документа. Хорошо бы на уже имеющемся языке, желательно международном,
составить нечто похожее на свой отдельный язык, где будут описаны правила, как он работает. Тут
можно провести параллель с виртуальной машиной, которая думает, что она отдельная система, но в
действительности она работает внутри уже имеющейся системы. Вот такую "_подсистему_" и решили
описать лингвисты в виде формального языка (**_formal language_**):

> In logic, mathematics, computer science, and linguistics, a **_formal language_** consists of
> words whose letters are taken from an alphabet and are well-formed according to a specific set of
> rules called a **_formal grammar_**.
>
> ~ [wiki](https://en.wikipedia.org/wiki/Formal_language)

Как мы видим, **_formal language_** обладает набором каких-то правил, что и делает его отдельным
языком. Такие правила назвали грамматикой (**_formal grammar_**). Если изучить её теорию подробнее,
то выйдем на следующие, поначалу непонятные термины:

-   [**_context-free grammar_**](https://en.wikipedia.org/wiki/Context-free_grammar)
-   [**_production rules_**](<https://en.wikipedia.org/wiki/Production_(computer_science)>)
-   [**_production_**](<https://en.wikipedia.org/wiki/Production_(computer_science)>)
-   [**_terminal_** и **_nonterminal symbols_**](https://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols)
-   [**_tokens_**](<https://en.wikipedia.org/wiki/Lexical_analysis#Token:~:text=Lexer%20(surname).-,Lexical%20tokenization%20is%20conversion%20of%20a%20text%20into%20(semantically%20or%20syntactically)%20meaningful%20lexical%20tokens%20belonging%20to%20categories%20defined%20by%20a%20%22lexer%22%20program.,-In%20case%20of>)

... и много чего ещё интересного.

Если говорить обобщённо, используя эти термины для какого-то своего языка, то у нас есть какая-то
своя грамматика (**_grammar_**), наподобие **_context-free grammar_**. Эта грамматика описана
правилами, называемыми **_production rules_**. Каждое правило состоит из своего **_production_**.
Сам он состоит из набора символов (**_nonterminal symbols_**) и, где это употребимо, токенов
(**_tokens_**). А этот набор, как групповое обобщение частных, неделимых примитивов, базовых единиц,
состоит из **_terminal symbols_**. Примерно в таком формате можно создать и описать свою языковую
модель.

Так уж вышло, что спецификация написана именно в таком стиле. Решили так _инженеры_ или _люди,
нанятые писать спецификацию_, я не знаю. Можно ли было сделать представление стандарта каким-либо
другим образом, более **_лёгким и понятным_**? Очевидно, что **_да, можно_**. Но сейчас спецификация
фактически является одной из форм реализации **_formal language_**, подчиняющейся базовой
грамматике, описанной на страницах стандарта. Это ровно то, что нам и нужно понять, чтобы идти
дальше.

## Базовая грамматика

Грамматика языка спецификации устроена так, что её сложность подразумевает разбиение на несколько
подграмматик (далее просто _грамматика_). Как мы верно подметили в прошлой главе, не стоит детально
запоминать особенности всех грамматик, ведь нам нужны только основные _грамматические правила_, о
которых дальше и пойдёт речь.

Все грамматики соответствуют правилам одной общей вида
[context-free grammar](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-context-free-grammars).
На её примере предлагаю рассмотреть основные
[грамматические обозначения](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-grammar-notation),
которые в общем случае будут справедливы для всех грамматик. Таких обозначений достаточно много, но
для общего понимания не требуется запоминать их все. Как и в прошлой главе, определим, согласно
спецификации, ряд общих и частных, из чего состоит условное "_предложение_", но только с точки
зрения терминов стандарта, и сразу рассмотрим их на реальном примере использования грамматики:

### Пример №1

<hr />

<FigureImage
    src='/myJS/img/get-started/1_1.png'
    caption='Пример типичного production для цикла while'
/>

[На картинке](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-nonterminal-symbols-and-productions)
мы видим типичное "_предложение_", но из мира спецификации. Всё это называется **_production_**. Из
таких и ещё более сложных конструкций состоит почти вся спецификация ECMAScript. На этом лёгком
примере мы можем встретить знакомый нам цикл `while` и что-то, похожее на его синтаксис. Давайте
сразу по порядку обозначим то, из чего состоит наш **_production_**.

-   **_WhileStatement_** — это **_goal symbol_**, то есть нечто, что стоит по левую сторону от
    символа "**_:_**", так называемый **_LeftHandSideSymbol_**. Одновременно с этим это ещё и
    **_nonterminal symbol_** (так как имеет стиль шрифта _italic_).
-   Символ "**_:_**" — разделяет **_production_** на две части, не имеет определения[^2]. Выполняет
    функцию идентификатора[^3] для одной из грамматик.
-   **_while_** — это **_token_**, который указывает, для какой конструкции языка ECMAScript написан
    данный production. Можно сказать, что с этой строчки вводится описание возможного синтаксиса
    (часть грамматики) языка ECMAScript, но это далеко не всегда так. Зачастую вы не увидите ничего
    схожего с синтаксисом JavaScript.
-   Символ "**_(_**" — это очередной **_token_**, который лекго распознать по стилю шрифта **bold**.
    Напоминает открывающуюся скобку синтаксиса объявления цикла `while` языка JavaScript.
-   **_Expression_** — это очередной **_nonterminal symbol_**, напоминающий условие работы цикла
    `while`.
-   Символ "**_)_**" — это такой же **_token_**, как и предыдущая скобка. Напоминает закрывающуюся
    скобку синтаксиса `while`.
-   **_Statement_** — это очередной **_nonterminal symbol_**, напоминающий блок кода, выполняемый
    циклом `while`.

Следом за этим примером предлагаю разобрать ещё один.

### Пример №2

<hr />

<FigureImage
    src='/myJS/img/get-started/1_2.png'
    caption='Сокращённый вариант написания VariableDeclaration production'
/>

Вот теперь на
[картинке](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-optional-symbols)
похожего нет совсем ничего. Давайте коротко опишем данный **_production_**:

-   **_VariableDeclaration_** — это **_goal symbol_**, **_nonterminal symbol_**.
-   Символ "**_:_**" — это сепаратор, разделитель и идентификатор определённого вида грамматики.
-   **_BindingIdentifier_** — это **_nonterminal symbol_**.
-   **_Initializer_** — это **_nonterminal symbol_**, **_optional symbol_**
-   **_opt_** — это **_suffix_**, указывающий на опциональность, что делает рядом стоящий символ
    необязательным для **_production_**-а. Используется только лишь в качестве сокращения. То есть в
    развёрнутом виде итоговый **_production_** будет выглядеть вот так:

<FigureImage
    src='/myJS/img/get-started/1_3.png'
    caption='Полный вариант написания VariableDeclaration production'
/>

<hr />

Итак, мы познакомились с базовыми грамматическими обозначениями, которые будут встречаться
повсеместно на страницах стандарта. Как и в обычном языке, в языке спецификации есть и другие
способы "_наполнить наши предложения_", но уже другими грамматическими конструкциями. Давайте
вкратце поговорим о них.

### Terminal symbols

В отличие от **_nonterminal symbol_**, который при выборе его в спецификации будет раскрыт на свои
составляющие и, возможно, представлять отдельный **_production_**, напротив, выбранный **_terminal
symbol_** - это такая же неделимая, нераскрывающаяся часть, как **_token_**, зависящая от того, в
какой грамматике она используется. Например, к **_terminal symbols_** могут относиться
[_Unicode **code points**_](https://en.wikipedia.org/wiki/Code_point#In_Unicode).

### Parameters

Параметры или **_grammatical parameters_** - это всего лишь разновидности суффиксов (**_suffix_**) и
префиксов (**_prefix_**) для наших **_nontermanal_**-ов. Они являются частью грамматики языка
спецификации и нужны для всевозможных сокращений потенциально больших по записи **_production_**-ов,
чтобы из огромных "_предложений_" сделать такие же по смыслу небольшие "_предложения_". Мы
ограничимся лишь картинками с их разновидностью, и как они раскрываются, но без углубления в детали.

<div align='center' style={{ margin: '1rem 0' }}>
    <img src='/myJS/img/get-started/1_4.png' alt='Image with grammar' />
    <img src='/myJS/img/get-started/1_5.png' alt='Image with grammar' />
    <img src='/myJS/img/get-started/1_6.png' alt='Image with grammar' />
    <img src='/myJS/img/get-started/1_7.png' alt='Image with grammar' />
</div>

<hr />

### И другие

В спецификации также введены свои дополнительные грамматические обозначения, которые вы сможете
увидеть в разделе
[_Grammar Notation_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-grammar-notation).
Среди них:

-   [**_one of_**](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-one-of)
-   [**_[empty]_**](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-empty)
-   [**_Lookahead Restrictions_**](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-lookahead-restrictions)
-   [**_[no LineTerminator here]_**](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-no-lineterminator-here)
-   [**_but not_**](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-no-lineterminator-here)
-   [**_Descriptive Phrases_**](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-descriptive-phrases)

<details>
<summary><i>An interesting fact...</i></summary>

Если вы заинтресовались грамматикой языков программирования, для более подробного изучения приглашаю
Вас в
[блог Роберта Нистрома](https://craftinginterpreters.com/representing-code.html#context-free-grammars).
Там есть ещё много интересного материала для изучения.

</details>

## Сложно?

Некоторым людям может показаться, что базовая грамматика языка спецификации ECMAScript неоправданно
сложна для понимания. Мы ещё не дошли до самых частных реализаций, а терминов уже много. У такого
подхода к написанию спецификации есть, как положительные, так и отрицательные стороны. Всё
негативное Вы, скорее всего, для себя уже заметили, поэтому я приведу несколько слов "за" этот
подход.

-   _Предельная точность описания_: чем больше и обширнее грамматическая языковая модель[^4], тем
    точнее будет описание.
-   _Научный подход_: редакторы спецификации избрали тяжёлый, но научный, **_с точки зрения
    лингвистики_**, путь создания языка.
-   _"Самый непонятый язык"_: если человек смог постичь спецификацию, он действительно знает, куда
    идёт по жизни.

## К выводу

Подведём итоги вышесказанному и сделаем выводы:

-   Термины спецификации "**_не любят_**" локализации на отличный от оригинала язык.
-   Для понимания грамматических конструкций не требуется досконально запоминать все их обозначения.
-   Способов создать свой язык достаточно много. Одним из них является способ представления некого
    **_formal language_** со своей **_context-free grammar_**, состоящей из **_productions_**,
    которые комбинируются с помощью **_nontermainals_**, **_termainals_** и **_tokens_**. Язык
    становится самостоятельным тогда и только тогда, когда приобретает свою неповторимую грамматику.
-   Спецификация ECMAScript наследует весь набор условного **_formal langiage_** с добавлением своих
    кастомных грамматических обозначений и расширяется благодаря комплексному подходу к
    инкапсулированию грамматик.
-   Вопрос детального описания самих грамматик представлен в [следующей главе](./Chapter_2.mdx).

[^1]:
    Так в 2005 году в своём блоге Брендан Эйх
    [рассуждал](<https://brendaneich.com/2005/06/javascript-1-2-and-in-between/#:~:text=does%20not%20need.-,JS%20is%20not%20going%20away%2C%20so%20it%20ought%20to%20evolve.%20As%20with%20sharks%20(and%20relationships%2C%20see%20Annie%20Hall)%2C%20a%20programming%20language%20is%20either%20moving%20forward%2C%20or%20it%E2%80%99s%20dead.,-Now%20dead%20languages>)
    на тему того, что мы хотим подразумевать, когда говорим о **_JavaScript_**-е: совокупность
    "[**_акронимов_**](https://brendaneich.com/2005/06/javascript-1-2-and-in-between/#:~:text=don%E2%80%99t%20like%20either-,acronym,-%2C%20I%20am%20asked)"
    или самодостаточный язык?

[^2]:
    Согласно спецификации, этот разделитель не имеет своего определения (термина), а очерёдность
    двоиточий определяется просто как "_Productions of the syntactic grammar are distinguished by
    having just one colon “:” as punctuation._"

[^3]: Имеется в виду грамматический идентификатор, помогающий различать разные грамматики.

[^4]:
    Авторский термин. Под грамматической языковой моделью я имею в виду модель (образ)
    повествования, определения и раскрытия грамматических правил языка.
