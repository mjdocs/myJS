---
id: algorithms
slug: /language-beginning/algorithms
title: Алгоритмы или "_Mr. ReturnIfAbrupt_"
description: Как реализованы алгоритмы в ECMAScript? Зачем они нужны?
sidebar_position: 3
sidebar_label: 3.4. Алгоритмы или "_Mr. ReturnIfAbrupt_"
---

import ChapterInfo from '@site/src/components/ChapterInfo/ChapterInfo'

<ChapterInfo type='formal' complexity='hard' time='?' />

# Глава 3.4: Алгоритмы или "_Mr. ReturnIfAbrupt_"

:::warning

Глава находится в разработке!

:::

В этой главе хочется рассказать о том, что из себя представляют
[алгоритмы](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions)
спецификации _ECMAScript_, зачем они нужны, как их правильно читать и понимать. Отдельное внимание
стоит уделить сокращениям и, так называемым, вариантам записей _"for notational convenience"_.
Верное прочтение алгоритмов спецификации крайне необходимо с точки зрения понимания, как работают
внутренние механизмы языка _ECMAScript_.

## Боль современности

В современном мире люди привыкли представлять работу _JavaScript_, как некоторую _"магию за
кадром"_. Всех начинающих разработчиков учат запоминать результаты тех или иных операций или их
цепочек, причём зачастую не имеющих ничего общего с языком. Делается это для ускоренного обучения,
так как всем хочется пораньше избавить себя от теоретической рутины и наконец, будучи преисполненным
в своём нелёгком умственном труде, "_подойти к веб-станку_". У всего этого есть своя неприятная
подоплёка.

_Человеческий мозг безумно ленив - это факт!_ На этом играют многие веб-ресурсы, предлагая быстрые
знания с гарантией их _"качественного"_ применения. Обычно там можно встретить выражения, типа
_"выучить за 1 час"_, _"быстро и без лишней воды"_, _"лёгко и доступно"_, _"через несколько месяцев
сможете брать заказы на фрилансе"_, _"20% теории и 80% практики"_, _"сможете показать диплом
работодателю"_ и многие другие...

В ходе гонки за быстрым результатом большинство, будь то _"учителя"_ или какой-нибудь веб-ресурс,
совершенно откровенно вторят молодым специалистам, что для текущего уровня знаний выгоднее что-то
запомнить или _"вызубрить"_, чем в этом детально разбираться. В действительности же, откинув ширму
забвения, новички становятся жертвой неполноценной системы обучения, которую _они_ или, наоборот,
_за них_ уже выбрали.

В итоге многие из таких людей уже с большим опытом разработки на _JavaScript_ намного позже **_на
подсознательном уровне_** не способны прийти к самостоятельной мысли о том, а что же **_на самом
деле_** представляет из себя их язык программирования.

## Скелет _ECMAScript_

Для того чтобы знать, что выбранная система обучения языку _JavaScript_ полноценна, а время на
изучение - оправданно, достаточно лишь посмотреть, на какие источники ссылается выбранный вами
ресурс. Определённо точно можно сказать: чем ближе к первоисточникам, тем выше шанс, что обучение
будет строиться не на догадках некоторых людей, делающих умный вид, а на фактах реализации.

Согласно спецификации, на её страницах с целью точного указания требуемой семантики конструкций
языка _ECMAScript_ часто используются некоторые пронумерованные списки. Они получили название -
**_алгоритмы_**. Давайте же познакомимся с ними подробнее и взглянем на их общую характиристику.

## Теория

### В _computer science_

Перед полноценным изучением алгоритмов спецификации языка _ECMAScript_ необходимо понять, какое
отражение они получили в современном мире. Что вообще такое _алгоритм_?

> In mathematics and computer science, **_an algorithm_** is a **_finite sequence_** of
> mathematically rigorous **_instructions_**, typically used to **_solve_** a class of specific
> **_problems_** or to **_perform a computation_**. Algorithms are used as **_specifications_** for
> performing calculations and data processing.
>
> ~ [wiki](https://en.wikipedia.org/wiki/Algorithm)

Как понятно из определения выше, алгоритм - просто последовательность инструкций для решения
каких-то проблем или выполнения вычислений. Так получилось, что эволюционно мир пошёл по пути
стандартизации и объективизации. Если есть какая-то нерешённая проблема или ряд нескольких проблем,
было придумано описывать это каким-то одним общим образом, при котором всем окружающим стало бы
понятно, о чём идёт речь, и сформировать один или несколько общих теоретических вариантов решения.

Теперь уже не нужно каждый раз придумывать, какую последовательность условных шагов необходимо
произвести, чтобы добиться желаемого результата.

Также важно отметить, что алгоритм по своей сути не обязательно должен использоваться только лишь
при абстрактоном описании решений чего-либо. Сегодня вполне вероятно алгоритмически описать просто
какой-нибудь отдельный процесс. Например, кто-то идёт на работу, и теоретически он может описать,
какие шаги он предпринимает для того, чтобы выйти из дома и дойти до офиса. То есть, собрав воедино
свои мысли и действия, отобразить это в каком-то общем алгоритмическом представлении.

Существует бесконечно много вариантов представления алгоритмов. Но как-то же должны регулироваться
общие подходы к их описанию? Давайте обратимся к мировому опыту:

> As an effective method, **_an algorithm_** can be expressed within a finite amount of **_space_**
> and **_time_** and in a well-defined **_formal language_** for calculating a function.
>
> ~ [wiki](https://en.wikipedia.org/wiki/Algorithm)

Из цитаты следует понимать, что эффективным методом представления алгоритма в общем виде является
формат уже известного нам **_formal language_**. В одной из глав про формирование принципов этого
языка подробно расписана вся теоретическая мысль данного подхода. Каждый человек при составлении
алгоритма сам определяет, каким будет его _formal language_, или выбирает уже существующие успешные
системы представления, например _блок-схемы_
([_flowchart_](https://en.wikipedia.org/wiki/Flowchart)) или реализация с помощью _машины Тьюринга_
([_Turing machine_](https://en.wikipedia.org/wiki/Turing_machine)).

### В программировании

Что ж, давайте немного отойдём от теоретической информатики и поговорим более приближённо про
алгоритмизацию в программировании. Как в этой области представлены общий опыт и практики.

> Boolos, Jeffrey & 1974, 1999 define **_an algorithm_** to be a **_set of instructions_** for
> determining an output, given explicitly, in a form that can be followed by either a computing
> machine or a human who could only carry out specific elementary operations on symbols.
>
> ~ [wiki](https://en.wikipedia.org/wiki/Algorithm#Definition)

И вновь мы сталкиваемся с неким _набором инструкций_. Если коротко, алгоритмами пытаются описывать
вообще все сущности программирования и даже его самого. Например, алгоритмами описывают механику
работы языков, архитектурные особенности постоения программ, сами программы и их взаимодействие с
памятью, а также многое-многое другое.

Одна из известных проблем, которую решают алгоритмы, - **_оптимизация_**. Как определить, насколько
эффективен написанный код? Если раньше писались целые отдельные книжки для указания самых
эффективных алгоритмических шагов некоторого языка программирования, то сейчас ситуация стремится к
единообразию. Некогда действительно работающие алгоритмы для одного языка делают справедливыми для
других. И это отдельная тема для разговора.

Также немалоизвестной проблемой, решающейся с помощью алгоритмов, является **_эффективное описание
внутренней машинерии_** языков программирования. Специалистам, разрабатывающим ПО, с которым
необходимо взаимодействовать тому или иному языку, важно знать, какие алгоритмические цепочки стоят
за ним, за каждой его операцией. Так, инженерам движка [_V8_](https://github.com/v8/v8) очевидно
важно иметь представление о том, как работают внутренние механизмы языка _JavaScript_, описанные в
спецификации.

:::note

Важно знать, что иногда в спецификации и её алгоритмической реализации бывают несовпадения.
_Делается это намеренно!_ Если инженерами был найден более эффективный метод решения одной задачи,
именно он и будет фигурировать в реализации в конечном итоге.

:::

## Алгоритмы _ECMAScript_

С точки зрения предмета нашего обсуждения - спецификации языка _ECMAScript_ - алгоритм - такая же
инструкция, но со своими особенностями реализации. Как уже было сказано выше, с целью точного
указания требуемой семантики конструкций языка _ECMAScript_ часто используются некоторые
_пронумерованные списки_, получившие название _"алгоритмы"_.

### Несоответствие реализации

В самом начале прописано, что алгоритмы не подразумевают использование какого-либо конкретного
метода реализации. На практике могут существовать **_более эффективные_** алгоритмы для реализации
некоторой технологии. Это
[явным образом](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions)
закреплено в спецификации. То есть за каждой отдельной реализацией, типа _V8_, сохраняется, как
выборочное право на применение **_более оптимизированного_** варината алгоритма, так и обязанность
**_следовать предсказуемости_** указанных алгоритмов вплоть до последней буквы.

### Грамматика

Ввиду того, что любая сущность спецификации требует _своего описания_, то и для алгоритмов необходим
какой-то порядок при их представлении. Существует несколько грамматических правил, помогающих
описывать механизмы языка _ECMAScript_.

Не будем тянуть, и поэтому давайте сразу обратимся к реальному примеру, чтобы рассмотреть всё
наглядно:

#### Example

<div align='center' style={{ margin: '1rem 0' }}>
    <img width='70%' src='/myJS/img/get-started/algorithm1.png' alt='Image with algorithm' />
</div>

Если детально изучить представленное изображение, мы увидим **_один большой алгоритм_** -
_ToPrimitive()_. Наверху представлен заголовок, и в данном случае это _абстрактная операция_ - один
из вариантов представления алгоритмов. Ниже - сам _алгоритм_.

#### Разбиение на шаги

Шаги
[_(Steps)_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions:~:text=Algorithm-,steps,-may%20be%20subdivided)
алгоритма _ECMAScript_ могут быть разделены на последовательные _подшаги_
[_(Substeps)_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions:~:text=subdivided%20into%20sequential-,substeps,-.%20Substeps%20are%20indented).
Об этом будут свидетельствовать видимая внутренная вложенность и нумерация того или иного шага и его
подшага. Так как все алгоритмы _инкапсулированы_ по отношению друг к другу, вводимые по ходу
сущности будут доступны _только внутри_ него самого и _только после объявления_.

[На картинке](#example) видно, что строки начинаются с _цифр_ или _букв_. Это _шаги_ и _подшаги_,
соответственно.

#### Параметризация

Любой алгоритм имеет потенциальную возможность _принимать_ какие-то внешние данные от других
алгоритмов через _параметры_
[_(Parameters)_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions:~:text=may%20be%20explicitly-,parameterized,-with%20an%20ordered).
Вместе с этим существуют варианты передачи результатов из одних алгоритмов в другие. Они
регулируются **_параметризацией_**. На страницах спецификации параметры чаще всего следуют сразу
после названия операции в круглых скобочках. Всего выделяют **_три вида_** параметров:

-   [_Required_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions-syntax-directed-operations:~:text=no%20different%20from-,required,-parameters%20within%20algorithm):
    обозначаются простым словом. Например, `ToPrimitive(input)`, где `input` - обязательный
    параметр.
-   [_Optional_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions-syntax-directed-operations:~:text=in%20that%20position.-,Optional,-parameters%20are%20denoted):
    обозначаются словом в квадратных скобках с запятой. Например,
    `ToPrimitive(input [, prefferedType])`, где `[, prefferedType]` - необязательный параметр.
-   [_Rest_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions-syntax-directed-operations:~:text=algorithm%20steps.%20A-,rest,-parameter%20may%20appear):
    обозначаются в самом конце всех параметров словом с многоточием. Собирает все аргументы, идущие
    после вышеуказанных в отдельный тип
    [_List_](https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-list-and-record-specification-type),
    изначально _пустой_. Например, `ToPrimitive(input [, prefferedType], ...name)`, где `...name` -
    текущий _rest_-параметер.

[На картинке](#example) абстрактная операция `ToPrimitive` принимает два параметра: **_required_** -
`input` и _optional_ - `[, prefferedType]`.

#### Предикаты

Алгоритмы могут иметь _вариативность_ шагов или по-простому _разветвления_. Для этого в спецификации
ввели некое обозначение под названием **_предикат_**
[_(Predicate)_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions:~:text=as%20an%20%E2%80%9Cif%E2%80%9D-,predicate,-that%20conditions%20its).
Всего выделяют **_два вида_** предикатов:

-   [_If и Else_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions:~:text=written%20as%20an%20%E2%80%9C-,if,-%E2%80%9D%20predicate%20that%20conditions):
    нужны для разветвления шага на несколько подшагов; определяют _условие_, с выполнением которого
    происходит выполнение подшагов _шага If_, а с невыполнением - _шага Else_ . Например,
    `1. If input is an Object, then`.
-   [_Assert_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions:~:text=that%20begins%20with%20%E2%80%9C-,Assert,-%3A%E2%80%9D%20asserts%20an%20invariant):
    нужен просто для пояснения алгоритмов; вводит некоторое ожидание для значения; определяет
    _всегда истинное_ инвариантное условие с одним искусственным разветвлением. Например,
    `1. Assert: prefferedType is NUMBER.`

[На картинке](#example) представлен алгоритм, в котором присутствуют, как `If / Else`, так и
`Assert` _предикаты_.

#### Псевдонимы

Алгоритмам необходимо всегда взаимодействовать с какими-либо значениями. Они могут быть _внешними_,
пришедшими с параметрами или просто глобальными в рамках спецификации, и _внутренними_. Доминирующее
превосходство по частоте использования одерживают _внутренние_, и с ними важно правильно
взаимодействовать. Для этого были придуманы _именованные псевдонимы_
[_(named aliases)_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions:~:text=may%20declare%20named-,aliases,-for%20any%20value).

Они по своей природе реализуются в формате _reference-like_, что определяет их схожесть в поведении
с ссылками [_(Reference)_](https://en.wikipedia.org/wiki/Reference#Computer_science). Эта схожесть
заключается в том, что _псевдоним_ указывает на те же данные, что и любая приводимая в той же строке
далее конструкция. Проще это будет осознать на примере:

<div align='center' style={{ margin: '1rem 0' }}>
    <img src='/myJS/img/get-started/algorithm2.png' alt='Image with algorithm' />
</div>

На этой картинке в первой строке представлена типичная инициализация псевдонима `x`. Исходя из
механизма их работы, согласно спецификации, как `x`, так и `someValue` обязаны указывать на одну и
ту же структуру данных, а изменение одного из них неотвратимо должно привести к аналогичному
изменению другого. После объявления на псевдоним можно ссылаться на любых _последующих и только
последующих_ шагах. Обозначается как `Let x be a someValue`. Подобное этому отображено и на
[картинке](#example).

Алгоритмы призваны быть гибкими, поэтому жёсткая сцепка двух сущностей одной стуктурой данных не
всегда является достаточным. Так был придуман принцип инициализации псевдонима, при котором он
ссылается не на уже лежащие в основе данные другой сущности, а на специально созданную **_копию_**
данных сущности, по сути, становясь самой копией. В таком случае модификация одной из сущностей
никак не скажется на другой. Обозначается как `Let x be a copy of someValue`. Такой вариант показан
во второй строке.

Ну и для модификации псевдонимов, чтобы указать ему, на какие новые данные необходимо теперь
ссылаться, существует обозначение через `Set x to someOtherValue`. Этот вариант показан в третьей
строке.

#### Значения

Иногда в алгоритмах можно встретить некоторые значения в **bold** стиле шрифта. Зачастую речь будет
идти о
[_ECMAScript language value_](https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-ecmascript-language-types).
Например, есть алгоритм, в котором выделенные значения являются просто _literals_ языка
_ECMAScript_:

1. Let _str_ be **"hello"**.
2. Let _num_ be **2**.
3. If _x_ is not **undefined**, then

Так, на [картинке](#example) нам представлены такие значения в количестве _пяти штук_.

#### Выход

По своему определению алгоритм - это **_конечная_** последовательность инструкций. В качестве итога
всегда выступает слово
[_Return_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions-syntax-directed-operations:~:text=nonterminal%20and%20then-,returns,-the%20result.%20For),
благодаря чему алгоритм _выходит_ с каким-то определённым результатом. Обычно форма возвращаемого
результата приводится в описании к операции.

[На картинке](#example) мы видим пример трёх явных выражений `Return` и одного неявного в строке
`Throw a TypeError exception.`, являющейся очередным сокращением _"for notational convenience"_,
которое внутри себя содержит тот же `Return`.

### Виды представления

На страницах спецификации существует **_три вида_** представления алгоритмов. Под представлением
подразумевается то, в каком виде они реализованы и как используются. Все представления

Сейчас стоит их расссматривать только как этапы реализации алгоритмов.

### _Shorthands_

:::tip[В разработке]

Продолжение следует...

:::
