---
id: algorithms-under-the-hood
slug: /language-beginning/algorithms-under-the-hood
title: Алгоритмы "под капотом"
description: Как реализованы алгоритмы в ECMAScript? Зачем они нужны?
sidebar_position: 3
sidebar_label: 3.4. Алгоритмы "под капотом"
---

import ChapterInfo from '@site/src/components/ChapterInfo/ChapterInfo'
import BlockQuote from '@site/src/components/BlockQuote/BlockQuote'
import FigureImage from '@site/src/components/FigureImage/FigureImage'

<ChapterInfo type='formal' complexity='normal' time='25' />
<BlockQuote id={6}>[^1]</BlockQuote>

# Глава 3.4: Алгоритмы "под капотом"

В этой главе хочется рассказать о том, что из себя представляют
[алгоритмы](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions)
спецификации _ECMAScript_, зачем они нужны, как их правильно читать и понимать. Отдельное внимание
стоит уделить сокращениям и, так называемым, вариантам записей _"for notational convenience"_.
Верное прочтение алгоритмов спецификации **_крайне необходимо_** с точки зрения понимания, как
работают внутренние механизмы языка _ECMAScript_.

## Боль современности

В наши дни люди привыкли представлять работу _JavaScript_, как некоторую _"магию за кадром"_. Всех
начинающих разработчиков учат запоминать результаты тех или иных операций или их цепочек, причём
зачастую не имеющих ничего общего с языком. Делается это для ускоренного обучения, так как всем
хочется пораньше избавить себя от теоретической рутины и наконец, будучи преисполненным в своём
нелёгком умственном труде, _"подойти к веб-станку"_. У всего этого есть своя неприятная подоплёка.

**_Человеческий мозг безумно ленив — это факт!_** На этом играют многие веб-ресурсы, предлагая
быстрые знания с гарантией их _"качественного"_ применения. Обычно там можно встретить выражения,
типа _"выучить за 1 час"_, _"быстро и без лишней воды"_, _"лёгко и доступно"_, _"через несколько
месяцев сможете брать заказы на фрилансе"_, _"20% теории и 80% практики"_, _"сможете показать диплом
работодателю"_ и многие другие...

В ходе гонки за быстрым результатом большинство, будь то _"учителя"_ или какой-нибудь веб-ресурс,
совершенно откровенно вторят молодым специалистам, что для текущего уровня знаний выгоднее что-то
запомнить или _вызубрить_, чем в этом детально разбираться. В действительности же, откинув ширму
забвения, новички становятся жертвой неполноценной системы обучения, которую _они_ или, наоборот,
_за них_ уже выбрали.

В нашем же случае так вышло, что тема внутренней машинерии языка _JavaScript_, описанная в
спецификации алгоритмами, намеренно пропускается с целью экономии времени и, в том числе, из-за
нехватки квалифицированных кадров, способных прочитать спецификацию.

В итоге многие из таких людей намного позже, уже с большим опытом разработки на _JavaScript_, к
сожалению, **_на подсознательном уровне_** не способны прийти к самостоятельной мысли, чтобы
задаться логичным вопросом: _"А что же **на самом деле** представляет из себя мой язык
программирования?"_

Для того чтобы определить, что выбранная система обучения языку _JavaScript_ полноценна, а время на
изучение — оправданно, достаточно лишь посмотреть, на какие источники ссылается выбранный вами
ресурс. Определённо точно можно сказать: чем ближе к первоисточникам, тем выше шанс, что обучение
будет строиться не на догадках некоторых людей, делающих умный вид, а _на фактах реализации._

## Теория

Согласно спецификации, на её страницах с целью точного указания требуемой семантики конструкций
языка _ECMAScript_ часто используются некоторые пронумерованные списки. Они получили название -
**_алгоритмы_**. Давайте же познакомимся с ними подробнее и взглянем на их общую характиристику.

### В _computer science_

Перед полноценным изучением алгоритмов спецификации языка _ECMAScript_ необходимо понять, какое
отражение они получили в современном мире. Что вообще такое _алгоритм_?

> In mathematics and computer science, **_an algorithm_** is a **_finite sequence_** of
> mathematically rigorous **_instructions_**, typically used to **_solve_** a class of specific
> **_problems_** or to **_perform a computation_**. Algorithms are used as **_specifications_** for
> performing calculations and data processing.
>
> ~ [wiki](https://en.wikipedia.org/wiki/Algorithm)

Как понятно из определения выше, алгоритм — просто последовательность инструкций для решения
некоторых проблем или выполнения вычислений. Так получилось, что эволюционно мир пошёл по пути
стандартизации и объективизации. Если есть какая-то нерешённая проблема или ряд нескольких проблем,
было придумано описывать это каким-то одним общим образом, при котором всем окружающим стало бы
понятно, о чём идёт речь, и сформировать один или несколько общих теоретических вариантов
эффективного решения.

Теперь уже не нужно каждый раз придумывать, какую последовательность условных шагов необходимо
произвести, чтобы добиться желаемого результата.

Также важно отметить, что алгоритм по своей сути не обязательно должен использоваться только лишь
при абстрактном описании решений. Сегодня вполне вероятно алгоритмически описать просто какой-нибудь
отдельный процесс. Например, кто-то идёт на работу, и теоретически он может описать, какие шаги он
предпринимает для того, чтобы выйти из дома и дойти до офиса. То есть, собрав воедино свои мысли и
действия, отобразить это в каком-то общем _алгоритмическом представлении._

Существует бесконечно много вариантов представления алгоритмов. Но как-то же должны регулироваться
общие подходы к их описанию? Давайте обратимся к мировому опыту:

> As an effective method, **_an algorithm_** can be expressed within a finite amount of **_space_**
> and **_time_** and in a well-defined **_formal language_** for calculating a function.
>
> ~ [wiki](https://en.wikipedia.org/wiki/Algorithm)

Из цитаты следует понимать, что эффективным методом представления алгоритма в общем виде является
формат уже известного нам **_formal language_**. В [одной из глав](./Chapter_1.mdx) про формирование
принципов этого языка подробно расписана вся теоретическая мысль данного подхода. Каждый человек при
составлении алгоритма сам определяет, каким будет его _formal language_, или выбирает уже
существующие успешные системы представления, например _блок-схемы_
([_flowchart_](https://en.wikipedia.org/wiki/Flowchart)) или реализация с помощью _машины Тьюринга_
([_Turing machine_](https://en.wikipedia.org/wiki/Turing_machine)).

### В программировании

Что ж, давайте немного отойдём от теоретической информатики и поговорим более приближённо про
алгоритмизацию в программировании. Как в этой области представлены общий опыт и практики.

> Boolos, Jeffrey & 1974, 1999 define **_an algorithm_** to be a **_set of instructions_** for
> determining an output, given explicitly, in a form that can be followed by either a computing
> machine or a human who could only carry out specific elementary operations on symbols.
>
> ~ [wiki](https://en.wikipedia.org/wiki/Algorithm#Definition)

И вновь мы сталкиваемся с неким _набором инструкций_. Если коротко, алгоритмами пытаются описывать
вообще все сущности программирования и даже его самого. Например, алгоритмами описывают механику
работы языков, архитектурные особенности постоения программ, сами программы и их взаимодействие с
памятью, а также многое-многое другое.

Одна из известных проблем, которую решают алгоритмы, — **_оптимизация_**. Как определить, насколько
эффективен написанный код? Если раньше писались целые книжки для указания самых эффективных
алгоритмических шагов некоторого языка программирования, то сейчас ситуация стремится к
единообразию. Некогда действительно работающие алгоритмы для одного языка делают справедливыми для
других. И это отдельная тема для разговора.

Также немалоизвестной проблемой, решающейся с помощью алгоритмов, является **_эффективное описание
внутренней машинерии_** языков программирования. Специалистам, разрабатывающим ПО, с которым
необходимо взаимодействовать тому или иному языку, важно знать, какие алгоритмические цепочки стоят
за ним, за каждой его операцией. Так, инженерам движка [_V8_](https://github.com/v8/v8) очевидно
важно иметь представление о том, как работают внутренние механизмы языка _JavaScript_, описанные в
спецификации.

:::note[Note]

Важно знать, что иногда в спецификации и её алгоритмической реализации бывают несовпадения.
_Делается это намеренно!_ Если инженерами был найден более эффективный метод решения одной задачи,
именно он и будет фигурировать в реализации в конечном итоге.

:::

## Алгоритмы _ECMAScript_

С точки зрения предмета нашего обсуждения — спецификации языка _ECMAScript_ — алгоритм — это такая
же инструкция, но со своими особенностями реализации. Как уже было сказано выше, с целью точного
указания требуемой семантики конструкций языка _ECMAScript_ часто используются некоторые
_пронумерованные списки_, получившие название **_алгоритмы_**.

### Несоответствие реализации

Спецификацией
[явным образом](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions)
закреплено, алгоритмы не подразумевают использование какого-либо конкретного метода реализации. На
практике могут существовать **_более эффективные_** воплощения некоторой технологии. То есть за
каждой отдельной реализацией, типа _V8_, сохраняется, как выборочное право на применение **_более
оптимизированного_** варината алгоритма, так и обязанность **_следовать предсказуемости_** указанных
алгоритмов вплоть до последней буквы.

### Грамматика

Ввиду того что любая сущность спецификации требует _своего описания_, то и для алгоритмов необходим
какой-то порядок их представления. Существует несколько базовых грамматических правил и обозначений,
помогающих описывать механизмы языка _ECMAScript_. Не будем тянуть и сразу обратимся к реальному
примеру, чтобы рассмотреть всё наглядно:

#### Example

<FigureImage
    src='/myJS/img/get-started/4_1.png'
    caption='Abstruct operation ToPrimitive() algorithm'
/>

Если детально изучить представленное изображение, мы увидим **_один большой алгоритм_** —
_ToPrimitive()_. Наверху обычно представлен заголовок, в данном случае это _абстрактная операция_ —
один из вариантов представления алгоритмов. [На картинке](#example) сам _алгоритм_.

#### Разбиение на шаги

Шаги
[_(Steps)_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions:~:text=Algorithm-,steps,-may%20be%20subdivided)
алгоритма _ECMAScript_ могут быть разделены на последовательные _подшаги_
[_(Substeps)_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions:~:text=subdivided%20into%20sequential-,substeps,-.%20Substeps%20are%20indented).
Об этом будут свидетельствовать видимая внутренная вложенность и нумерация того или иного шага и его
подшага. Так как все алгоритмы _инкапсулированы_ по отношению друг к другу, вводимые по ходу
сущности будут доступны _только внутри_ него самого и _только после объявления_.

[На картинке](#example) видно, что строки начинаются с _цифр_ или _букв_. Это _шаги_ и _подшаги_,
соответственно.

#### Параметризация

Любой алгоритм имеет потенциальную возможность _принимать_ какие-то внешние данные от других
алгоритмов через _параметры_
[_(Parameters)_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions:~:text=may%20be%20explicitly-,parameterized,-with%20an%20ordered).
Вместе с этим существуют варианты передачи результатов из одних алгоритмов в другие. Они
регулируются **_параметризацией_**. На страницах спецификации параметры чаще всего следуют сразу
после названия операции в круглых скобках. Всего выделяют **_три вида_** параметров:

-   [_Required_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions-syntax-directed-operations:~:text=no%20different%20from-,required,-parameters%20within%20algorithm):
    обозначаются простым словом. Например, `ToPrimitive(input)`, где `input` — обязательный
    параметр.
-   [_Optional_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions-syntax-directed-operations:~:text=in%20that%20position.-,Optional,-parameters%20are%20denoted):
    обозначаются словом в квадратных скобках с запятой. Например,
    `ToPrimitive(input [, prefferedType])`, где `[, prefferedType]` — необязательный параметр.
-   [_Rest_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions-syntax-directed-operations:~:text=algorithm%20steps.%20A-,rest,-parameter%20may%20appear):
    обозначаются в самом конце всех параметров словом с многоточием. Собирает все аргументы, идущие
    после вышеуказанных в отдельный тип
    [_List_](https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-list-and-record-specification-type),
    изначально _пустой_. Например, `ToPrimitive(input [, prefferedType], ...name)`, где `...name` —
    текущий _rest_-параметер.

[На картинке](#example) абстрактная операция `ToPrimitive` принимает два параметра: _required_ —
`input` и _optional_ — `[, prefferedType]`.

#### Предикаты

Алгоритмы могут иметь _вариативность_ шагов или по-простому _разветвления_. Для этого в спецификации
ввели некое обозначение под названием **_предикат_**
[_(Predicate)_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions:~:text=as%20an%20%E2%80%9Cif%E2%80%9D-,predicate,-that%20conditions%20its).
Всего выделяют **_два вида_** предикатов:

-   [_If и Else_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions:~:text=written%20as%20an%20%E2%80%9C-,if,-%E2%80%9D%20predicate%20that%20conditions):
    нужны для разветвления шага на несколько подшагов; определяют _условие_, с выполнением которого
    происходит выполнение подшагов _шага If_, а с невыполнением — _шага Else_ . Например,
    `1. If input is an Object, then`.
-   [_Assert_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions:~:text=that%20begins%20with%20%E2%80%9C-,Assert,-%3A%E2%80%9D%20asserts%20an%20invariant):
    нужен просто для пояснения алгоритмов; вводит некоторое ожидание для значения; определяет
    _всегда истинное_ инвариантное условие с одним искусственным разветвлением. Например,
    `1. Assert: prefferedType is NUMBER.`

[На картинке](#example) представлен алгоритм, в котором присутствуют, как `If / Else`, так и
`Assert` _предикаты_.

#### Псевдонимы

Алгоритмам необходимо всегда взаимодействовать с какими-либо значениями. Они могут быть _внешними_,
пришедшими с параметрами или просто глобальными в рамках спецификации, и _внутренними_. Доминирующее
превосходство по частоте использования одерживают _внутренние_, и с ними важно правильно
взаимодействовать. Для этого были придуманы _именованные псевдонимы_
[_(named aliases)_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions:~:text=may%20declare%20named-,aliases,-for%20any%20value).

Они по своей природе реализуются в формате _reference-like_, что определяет их схожесть в поведении
с ссылками [_(Reference)_](https://en.wikipedia.org/wiki/Reference#Computer_science). Эта схожесть
заключается в том, что _псевдоним_ указывает на те же данные, что и любая приводимая в той же строке
далее конструкция. Проще всего это можно понять на примере:

<FigureImage src='/myJS/img/get-started/4_2.png' caption='Named alias declaration/modification' />

На этой картинке в первой строке представлена типичная инициализация псевдонима `x`. Исходя из
механизма их работы, согласно спецификации, как `x`, так и `someValue` обязаны указывать на одну и
ту же структуру данных, а изменение одного из них необратимо должно привести к аналогичному
изменению другого. После объявления псевдонима на него можно ссылаться на любых _последующих и
только последующих_ шагах. Обозначается как `Let x be someValue`. Подобное этому отображено и на
[картинке](#example).

Алгоритмы призваны быть гибкими, поэтому жёсткая сцепка двух сущностей одной стуктурой данных не
всегда является достаточным. Так был придуман принцип инициализации псевдонима, при котором он
ссылается не на уже лежащие в основе данные другой сущности, а на специально созданную **_копию_**
данных сущности, по сути, становясь самой копией. В таком случае модификация одной из сущностей
никак не скажется на другой. Обозначается как `Let x be a copy of someValue`. Такой вариант показан
во второй строке.

Ну и для модификации псевдонимов, чтобы указать ему, на какие новые данные необходимо теперь
ссылаться, существует конструкция вида `Set x to someOtherValue`. Этот вариант показан в третьей
строке.

#### Значения

Иногда в алгоритмах можно встретить некоторые значения в **bold** стиле шрифта. В таком случае речь
будет идти о
[_ECMAScript language value_](https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-ecmascript-language-types).
Например, есть алгоритм, в котором выделенные значения являются просто _LiteralExpressions_ языка
_ECMAScript_:

1. Let _str_ be **"hello"**.
2. Let _num_ be **2**.
3. If _x_ is not **undefined**, then

Так, на [картинке](#example) нам представлены такие значения в количестве _пяти штук_.

#### Выход

По своему определению алгоритм — это **_конечная_** последовательность инструкций. В качестве итога
всегда выступает слово
[_Return_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions-syntax-directed-operations:~:text=nonterminal%20and%20then-,returns,-the%20result.%20For),
благодаря чему алгоритм _выходит_ с каким-то определённым результатом. Обычно форма возвращаемого
результата приводится в описании к операции.

[На картинке](#example) мы видим пример трёх явных выражений `Return` и одного неявного в строке
`Throw a TypeError exception.`, являющейся очередным сокращением _"for notational convenience"_,
которое внутри себя содержит тот же `Return`.

### Виды представления

На страницах спецификации существует **_три вида_** представления алгоритмов. Под представлением
подразумевается то, в каком виде они реализованы и как используются. Давайте рассмотрим их
детальнее:

:::note[Note]

В рамках данной темы следующие подзаголовки будут рассматриваться исключительно как сущности,
описывающие алгоритмы спецификации языка ECMAScript. Они также имеют и другой смысл относительно
всей внутренней машинерии, но это мы намеренно отложим до следующих глав.

:::

#### Syntax-directed operations

_Синаксически-ориентированная_
[_(Syntax-directed)_](https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-syntax-directed-operations)
операция представляет из себя **_артефакт спецификации_**[^2], необходимый для связывания различных
синтаксических конструкций и лежащих в их основе алгоритмов. Это наиболее частый вариант
представления из указанных.

Самым известным примером _syntax-directed_ операции является
[_Runtime Semantics: Evaluation_](https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-evaluation),
благодаря которой описано внутреннее поведение всех возможных синтаксических конструкций ECMAScript.

Также большинство операций, выполняющихся перед фактическим выполнением кода на этапе
[_Runtime Semantics_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-runtime-semantics),
тоже имеют _syntax-directed_ природу и входят в состав
[_Static Semantics_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-static-semantic-rules)
— некоторый набор правил в помощь к сложившейся _production-системе_ определения валидности потоков
токенов для дальнейшей оценки.

Так как здесь лишь обзорно рассматриваются алгоритмические представлений, определение значения
вышеупомянутых терминов будет отложено для более предметных глав.

#### Abstruct operations

_Абстрактная операция_
[_(Abstruct operation)_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions-abstract-operations)
представляет из себя очередной **_артефакт спецификации_**, необходимый для облегчённого описания
алгоритмов. В данном случае справедливо будет провести параллель с
[_декларативным стилем_](https://en.wikipedia.org/wiki/Declarative_programming) программирования, в
котором предпочтение отдаётся разбиению кода на смысловые части, имеющие общую самостоятельную
компонентно-инкапсулированную логику, а не поочерёдному выполнению примитивных операций, как в
[_императивном стиле_](https://en.wikipedia.org/wiki/Imperative_programming).

Так вот с абстрактными операциями дела обстоят ровно так же. Каждая по отдельности выполняет свою
роль в общей декларативной модели. И все вместе они образуют некое подобие декларативного описания,
при котором каждый алгоритм может вызывать на каком-либо из шагов необходимую в данный момент
абстрактную операцию, которая, в свою очередь, может вызвать внутри себя ещё одну, и так далее.

Распознать абстрактную операцию зачастую можно по наличию параметров в круглых скобках. Более
детальная информация представлена в качестве описания к каждой операции в отдельности.

Так, в спецификации мы можем
[наблюдать](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-toprimitive) уже
известный нам пример абстрактной операции `ToPrimitive()`.

#### Methods

Отдельный вариант представления алгоритмов — _методы языка ECMAScript_. Они регулируют поведение
внутренней машинерии языка, как должны вести себя реальные методы в JavaScript. Благодаря им можно
получить полное представление о том, что происходит в момент использования той или иной функции.

Так, например, в спецификации с помощью тех же самых алгоритмов
[представлена](https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-function.prototype.bind)
работа метода `bind()`.

## К выводу

Подведём итоги вышесказанному и сделаем выводы:

-   Современное изучение JavaScript зачастую имеет поверхностную неглубинную природу, никак не
    связанную с реальным положением вещей. Тема алгоритмов "под капотом" заменяется на частичное
    запоминание распространённых случаев.
-   На самом деле алгоритмы внутренней машинерии языка ECMAScript - базовое ядро на пути к
    полноценному пониманию работы языка.
-   Для алгоритмов введена своя грамматика, помогающая структуризировать их написание и понимание.
    Можно уверенно сказать, что она далеко не идеальная, до сих пор находят баги спецификации. И да,
    можно было сделать её более "человеческой".
-   Алгоритмы имеют три распространённые формы представления, каждая из которых образует свой
    принцип описания языка.
-   Грамматика алгоритмов не ограничивается базовыми правилами. Их верное прочтение невозможно без
    знания ["продвинутых" обозначений](../AdvancedAlgorithms.mdx).

[^1]:
    Фраза из известной монографии _«The Art of Computer Programming»_, представленной в 1968 году
    американским учёным в области математики и информатики — профессором
    [Дональдом Кнутом](https://en.wikipedia.org/wiki/Donald_Knuth). Этот труд до сих пор на завершён
    и продолжает писаться.

[^2]:
    Артефакт спецификации — термин, присущий именно самой спецификации без необходимости реализации.
    Стоит его рассматривать исключительно как _сущность языка спецификации ECMAScript_ и не более.
