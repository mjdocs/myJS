---
id: advanced-algorithms
slug: /advanced-algorithms
title: Продвинутые алгоритмы
description: Углублённое понимание грамматики алгоритмов ECMAScript.
sidebar_position: 5
sidebar_label: 5. Продвинутые алгоритмы
---

import ChapterInfo from '@site/src/components/ChapterInfo/ChapterInfo'
import BlockQuote from '@site/src/components/BlockQuote/BlockQuote'
import FigureImage from '@site/src/components/FigureImage/FigureImage'
import Enum from '@site/src/ui/Enum/Enum'

<ChapterInfo type='formal' complexity='hard' time='20' />
<BlockQuote id={7}>[^1]</BlockQuote>

# Глава 5: Продвинутые алгоритмы

:::warning

Глава находится в разработке!

:::

В этой главе хочется углубиться в тему грамматики языка алгоритмов спецификации ECMAScript. Мы
узнаем, что обозначают сокращения **_"!"_** и **_"?"_**, почему `Return true` не всегда возвращает
`true`, как обарабатываются ошибки и почему не стоит доверять всему тому, что вы видите в
спецификации.

:::note[Note]

Далее речь пойдёт не об алгоритмах языка программирования JavaScript в общем их представлении. Здесь
будут рассматриваться _грамматические уловки_ языка алгоритмов ECMAScript, которые имеют огромное
значение для понимания всей спецификации. Прошу отнестить к этому серьёзно.

:::

## Введение

Благодаря алгоритмам спецификации любой специалист может научиться понимать внутреннюю природу
выполнения кода и прогнозировать его поведение. И здесь я говорю больше не о последовательности
выполнения того или иного _statement_-а, а о предложенных спецификацией инструкциях, позволяющих
оценить количество и качество происходящих "под капотом" действий, чтобы на их основе оценить
возможные затрачиваемые ресурсы и эффективность выбранного метода разработки.

За эффективность выполнения кода отвечает движок _V8_. На сегодняшний день он способен
оптимизировать даже самые неочевидные моменты в любом коде, но всему есть предел. Поэтому задачей
любого разработчика на JavaScript является не только знать алгоритмы, лежащие в основе каждой
исполняемой операции, но и уметь разрабатывать свои продукты так, чтобы оптимизирующий движок смог
безпрепятственно выполнить свою главную задачу — наилучшим образом скомпилировать код.

Как обсуждалось в предыдущих главах, знание только лишь лежащих в основе языка алгоритмов не
гарантирует разработчику эффективность их выполнения относительно всей программы. Но без этих знаний
мы вынуждены обрекать себя на игру в вероятности с такими точными вещами, которые не прощают к себе
халатного отношения.

## Погружение

Алгоритмы спецификации ECMAScript, ровно как и её грамматика, кажутся обманчиво простыми, но за этой
простотой скрываются поистине сложные решения редакторов Ecma. **_Первый принцип_**, с которым
необходимо начинать рассматривать любую её сущность или артефакт, заключается в изолировании своих
знаний — **_забудьте всё, что приходилось изучать ранее_**.

Как бы это пародоксально ни звучало, но знания, принесённые из других языков, только _собьют_ с
нужного пути. И далее вы поймёте, почему это так.

### Загадочный `Evaluation of`

Одним из сложных и неочевидных моментов в прочтении алгоритмов является конструкция `Evaluation of`.
И почему вообще _Evaluation_? Давайте рассмотрим пример ниже и попытаемся объяснить, какую роль
выполняет эта конструкция.

<FigureImage
    src='/myJS/img/advanced_algorithms/1_1.png'
    caption='Equality Operators — RS: Evaluation'
/>

Первое, что мы видим на картинке, — стадия выполнения кода ECMAScript под названием **_Runtime
Semantics: Evaluation_** (далее **_RS: Evaluation_**). Иными словами, _syntax-directed_ операция,
возвращающая _Completion Record_. Она гласит нам о том, что для низлежащего _production_-а во время
выполнения кода (а именно во второй стадии выполнения) должен быть применён представленный далее
алгоритм. Все эти сущности в достаточной форме можно увидеть на картинке.

Во второй строке представлен уже известный нам _production_ с токеном **_==_**. Очевидно, что в
данном случае речь пойдёт об операторе _свободного (нестрогого) равенства_. Синтаксис задаёт
_syntactic grammar_, указывающий на возможный вариант написания выражения, чтобы парсер смог успешно
распознать поток _Unicode code points_, именно как данное выражение. То есть текущему _production_-у
вполне может соответствовать такое выражение:

```javascript
5 == 7 // EqualityExpression
```

Уже с третьей строки последовательно представлены шаги алгоритма, описывающие выполнение этого
выражения. И тут мы натыкаемся на загадочные `Evaluation of`. Данная конструкция _обязательна_,
потому что во время выполнения кода возникает острая _необходимость оценить_, с чем именно предстоит
работать нашей программе, что именно нужно сравнивать. И здесь наступает важный для понимания этап.

Дело в том, что при разборе _production_-а перед нами предстают 3 _nonterminal values_. И это
неслучайно, так как _goal symbol_ (в нашем случае _EqualityExpression_) не является единственным
выполняемым выражением. Согласно спецификации, в любой строке кода, подобной той, что представлена
выше, **_содержится 3 выражения_**. И для всех трёх выражений необходимо провести этап оценки
[_(RS: Evaluation)._](https://tc39.es/ecma262/multipage/syntax-directed-operations.html#sec-evaluation)

Именно поэтому на этапе _Evaluation_ для представленного на картинке _left-hand-side_ выражения
_EqualityExpression_ происходит, как минимум, два этапа _Evaluation_ для двух _right-hand-side_
выражений по обе стороны от **_==_**. То есть для них буквально выполняются те же самые стадии
оценки _RS: Evaluation_, результаты которых, согласно приведённому на картинке алгоритму,
связываются с соответствующими _псевдонимами_ для последующих манипуляций.

Алгоритмическая конструкция `Evaluation of` — эта просто удобное написание, некая отсылка к
выполнению _syntax-directed_ операции над далее идущим выражением, с целью предварительной оценки
значения перед последующим манипулированием над ним.

### Неочевидный `Return`

Ранее мы установили, что по определению алгоритм — это **_конечная_** последовательность инструкций,
где в качестве конечного пункта (выход из алгоритма) _всегда_ выступает слово
[_Return_](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-algorithm-conventions-syntax-directed-operations:~:text=nonterminal%20and%20then-,returns,-the%20result.%20For),
даже если в момент выполнения кода происходит ошибка. Благодаря чему алгоритм _всегда выходит с
каким-то определённым результатом_.

В случае с _syntax-directed_ операциями конструкция `Return` **_с единственным исключением_**
_всегда_ возвращает значение, указанное в описании к операции без использования дополнительных
proxy-конструкций[^2], о которых дальше пойдёт речь. То есть, если в условно третьей строке выход из
алгоритма происходит посредством `3. Return true`, такая операция вернёт ожидаемое _ECMAScript
language value_ — **true**.

В случае же с _abstruct_ операциями и тем самым исключением в виде _syntax-directed_ операции _RS:
Evaluation_ конструкция `Return`, согласно спецификации, **_всегда дополнительно_** применяет для
возвращаемого значения некоторую _proxy-конструкцию_, которая его _полностью изменяет_.

#### _Proxy_-конструкция

Ещё её можно назвать _"промежуточной операцией"_. В спецификации этот раздел называется
[Implicit Normal Completion](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-implicit-normal-completion).
Это некоторое правило, согласно которому, над возвращаемым значением, перед тем как его вернуть,
происходят указанные действия. То есть прежняя конструкция `Return true` исходя из этого правила
превращается в ряд дополнительных шагов:

<FigureImage src='/myJS/img/advanced_algorithms/1_3.png' caption='Implicit Normal Completion' />

По итогу, согласно этому правилу, любое значение на выходе из алгоритма _abstruct_ операции должно
быть завёрнуто в _Completion Record_ и, следовательно, будет использоваться в других алгоритмах
именно как _Completion Record_. Предлагаю рассмотреть этот подход на реальном примере:

<FigureImage
    src='/myJS/img/advanced_algorithms/1_2.png'
    caption='Operations on Objects — set the value of a specific property'
/>

Перед нами _abstruct_ операция `Set()`. В её алгоритме представлено два варианта выхода: `throw` и
`Return`. Первый из них будет разобран позже, поэтому давайте обратим внимание на второй —
`3. Return UNUSED`. Если бы это была _syntax-directed_ операция, то, вероятнее всего, если в
описании не указано иного, было бы возвращено некоторое значение <Enum>unused</Enum> типа
[_Enum_](https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-enum-specification-type).

Но в данном случае мы имеем дело с _abstruct_ операцией, так что, согласно правилу _Implicit Normal
Completion_, `3. Return UNUSED` будет изменено в
`3. Return Completion Record { [[Type]]: NORMAL, [[Value]]: UNUSED, [[Target]]: EMPTY }.`

### Выбрасываемый `throw`

Так называемый "выброс исключения" в разных языках программирования _отчасти_ существует таким,
каким его привыкли представлять, и в языке ECMAScript. С точки зрения спецификации это не заставляет
программу "выпасть в ошибку". На самом деле `throw` является всего лишь _отдельным случаем_ уже
известной нам конструкции `Return`, который следует отдельному алгоритму:

<FigureImage
    src='/myJS/img/advanced_algorithms/1_4.png'
    caption='Throw an Exception under the hood'
/>

Как можно заметить, возвращается всё тот же _Completion Record_, но с другим значением типа _Enum_
внутреннего поля [[_Type_]] — <Enum>throw</Enum>, а объект исключения занимает поле [[_Value_]] и
зависит от соответствующего исключения.

Рассмотренный выше пример соответствует выбросу исключения алгоритмами спецификации языка ECMAScript
в результате ошибки компиляции. Но ровно по тому же принципу работает и явный
[_ThrowStatement_](https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#prod-ThrowStatement)
— команда `throw` в JavaScript.

### Скрытный _Mr. `ReturnIfAbrupt()`_

Более сложными грамматическими обозначениями языка алгоритмов являются префиксы `!` и `?`. Пожалуй,
это две _самые запутанные конструкции_ во всех алгоритмах. Их использование можно увидеть на той же
картинке, что была выше.

<FigureImage
    src='/myJS/img/advanced_algorithms/1_1.png'
    caption='Equality Operators — RS: Evaluation'
/>

Здесь представлены 5 шагов алгоритма, и все из них содержат загадочный префикс `?`. Обращаю
внимание, что он находится _строго перед операциями_. Чтобы понять, почему он так необходим, важно
заглянуть внутрь всех них и узнать, что они возвращают (с каким значением производится выход из
алгоритма в результате `Return` или его скрытого варианта `throw`).

Нам уже известно, что, согласно спецификации, _syntax-directed_ операция `Evaluation of` всегда
возвращает _Completion Record_. Аналогичным образом _abstruct_ операции `GetValue()` и
`IsLooslyEqual()` возвращают, согласно алгоритмам, тот же _Completion Record_. Ранее мы пришли к
осознанию того, что значения с помошью `Let ... be ...` зачастую связываются с некими _alias_
(псевдонимами). Полчается, в данном случае связывание происходит с теми же сущностями _Completion
Record?_ Ответ: **_нет_**.

_В это месте и проявляется скрытая природа языка алгоритмов._ Всё дело в неком алгоритмическом
_предопределённом переопределении_.

#### Предопределяем исключение с `?`

Этим заголовком справедливо будет выразить всю ту машинерию, которая заложена внутри обозначений `?`
и `!` в алгоритмах. Его смысл вы поймёте чуть дальше.

В основе этих двух конструкций лежит логика грамматических сокращений
[(_Shorthands_)](https://tc39.es/ecma262/multipage/notational-conventions.html#sec-returnifabrupt-shorthands).
Рассмотрим работу самого частого их них — префикса `?` — на шаблонном примере:

<FigureImage
    src='/myJS/img/advanced_algorithms/1_5.png'
    caption='Prefix "?" shorthand under the hood'
/>

Как можно заметить, префикс `?` просто оборачивает операцию справа в некоторую конструкцию
`ReturnIfAbrupt()`. На этом его миссия, как части языка алгоритмов, завершена. Это всего лишь
сокращение для другого алгоритма — вышеупомянутого `ReturnIfAbrupt()`. Так давайте же посмотрим,
какие шаги кроются за ним:

<FigureImage src='/myJS/img/advanced_algorithms/1_6.png' caption='ReturnIfAbrupt under the hood' />

Выше представлен разбор алгоритма `ReturnIfAbrupt()` согласно спецификации. Чтобы понять его смысл,
стоит разобрать каждую строку:

-   `1. Let hygienicTemp be AbstractOperation().` — связываем с _alias_-ом `hygienicTemp` сущность
    _Completion Record_, как результат асбтрактной операции `AbstractOperation()`. То есть
    `hygienicTemp` указывает на те же данные, что и вышеупомянутый _Completion Record_.
-   `2. Assert: hygienicTemp is a Completion Record.` — вспомогательный _predicate_ `Assert:`,
    указывает семантическое ожидание, какое значение задумывалось обрабатывать этим алгоритмом. В
    нашем случае это совпало.
-   `3. If hygienicTemp is an abrupt completion, return Completion(hygienicTemp).` — разветвляющий
    _predicate_ `If`, проверяет значение _Completion Record_ на _abrupt completion_, чтобы в таком
    случае выйти из нашего алгоритма со значением
    `Completion Record { [[Type]]: ABRUPT, [[Value]]: value, [[Target]]: EMPTY }.`, где вместо
    `value` будет помещён объект исключения.
-   `4. Else, set hygienicTemp to hygienicTemp.[[Value]].` — разветвляющий _predicate_ `Else`,
    **_переопределяет_** (пересвязывает) `hygienicTemp` _alias_ с помощью конструкции
    `Set ... to ...` так, что теперь он указывает на внутреннее поле _Completion Record_ —
    `hygienicTemp.[[Value]]` — теперь просто обычный _ECMAScript language value_.

Исходя из разобранного теоретического примера следует, что в реальном алгоритме после употребления
префикса `?` происходит оценка возвращаемого _abstruct_ операцией значения. Если это _abrupt
completion_, вернуть его же с объектом исключения; в противном случае переопределить _alias_ и
неявно вернуть его со ссылкой на внутреннее поле _Completion Record_ [[Value]].

Благодаря этой машинерии получилось описать целую систему обработки ошибок на любом из шагов
алгоритма, хоть она и далеко не идеальная.

#### Предопределяем отсутствие исключения с `!`

Для этих же целей используется и префикс `!`, но немного в другом контексте. Давайте, согласно
спецификации, рассмотрим его алгоритм на шаблонном алгоритме:

<FigureImage
    src='/myJS/img/advanced_algorithms/1_7.png'
    caption='Prefix "!" shorthand under the hood'
/>

-   `1. Let val be OperationName().` — связываем с _alias_-ом `val` результат некоторой операции
    (_abstruct_ или _syntax-directed_).
-   `2. Assert: val is a normal completion.` — вспомогательный _predicate_ `Assert:`, указывает
    семантическое ожидание, какое значение задумывалось обрабатывать этим алгоритмом. В данном
    случае `Completion Record { [[Type]]: NORMAL, [[Value]]: value, [[Target]]: EMPTY }.`.
-   `3. Set val to val.[[Value]].` — **_переопределяет_** (пересвязывает) `val` _alias_ с помощью
    конструкции `Set ... to ...` так, что теперь он указывает на внутреннее поле _Completion Record_
    — `val.[[Value]]` — теперь просто обычный _ECMAScript language value_.

Этот алгоритм гарантирует, что вызов _любой_ операции не вернёт _abrupt completion_.

## К выводу

Подведём итоги вышесказанному и сделаем выводы:

-   Алгоритмы не так просты в прочтении, когда дело доходит до глубокого понимания.
-   Конструкция `Evaluation of` — это просто сокращённая запись вызова второй стадии выполения кода
    _RS: Evaluation_ для отдельного выражения.
-   Конструкции `Return` и `throw` — это почти идентичные выходы из алгоритмов. В случае с _abrupt_
    операциями и одной _syntax-directed RS: Evaluation_ операции для возвращаемого значения
    применяется _proxy_-конструкция. Для других такого правила не действует.
-   Префиксы `?` и `!` — сокращённые записи для предопределённой обработки исключений.

[^1]:
    Фраза из книги _Code Complete_: практическое руководство по созданию программного обеспечения
    Стива МакКоннелла

[^2]:
    Proxy-конструкция — авторский термин, описывающий некоторую внутреннюю машинерию языка,
    выступающую неявным обработчиком значения, намеренно изменяющим его перед последующим
    возвращением в другую операцию в рамках отведённых правил.
